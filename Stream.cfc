component accessors="true"{

    // The Java Stream we represent
    property name="jStream";

    // Static Stream Class Access
    variables.coreStream    = createObject( "java", "java.util.stream.Stream" );
    variables.longStream    = createObject( "java", "java.util.stream.LongStream" );

    /**
     * Construct a stream
     *
     * @collection This is an optional collection to build a stream on: List, Array, Struct, Query
     */
    Stream function init( any collection="" ){

        // If a list, enhance to array
        if( isSimpleValue( arguments.collection ) ){
            arguments.collection = arguments.collection.listToArray();
        }

        // If Array
        if( isArray( arguments.collection ) ){
            variables.jStream = arguments.collection.stream();
            return this;
        }
        
        // If Struct
        if( isStruct( arguments.collection ) ){
            variables.jStream = arguments.collection.entrySet().stream();
            return this;
        }

        // If Query
        if( isQuery( arguments.collection ) ){

        }

        throw( 
            message="Cannot create stream from incoming collection",
            type="InvalidColletionType",
            detail="#getMetadata( arguments.collection ).toString()#" 
        );
    }

    /**
     * Returns a sequential ordered stream whose elements are the specified values.
     * Each argument passed to this function will generate the stream from.
     * 
     */
    Stream function of(){
        if( arguments.isEmpty() ){
            throw( message="Please pass at least one value", type="InvalidValues" );
        }
        return init( arrayNew( 1 ).append( arguments, true ) );
    }

    /**
     * Create a character stream from a string
     *
     * @target The string to convert to a stream using its characters 
     */
    Stream function chars( required string target ){
        variables.jStream = arguments.target.chars();
        return this;
    }

    /**
     * Create a stream from a file. Every line of the text becomes an element of the stream:
     *
     * @path The absolute path of the file to generate a stream from
     */
    Stream function file( required string path ){

        variables.jStream = createObject( "java", "java.nio.file.Files" ).lines( 
            createObject( "java", "java.nio.file.Paths" ).get( 
                createObject( "java", "java.io.File" ).init( arguments.path ).toURI()
            )
        );

        return this;
    }

    /**
     * Returns an infinite sequential unordered stream where each element is generated by the provided Supplier. 
     * This is suitable for generating constant streams, streams of random elements, etc. Please make sure you limit
     * your stream or this method will work until it reaches the memory limit. Use the <code>limit()</code>
     * 
     * @supplier A closure or lambda that will supply the generated elements
     */
    Stream function generate( required supplier ){
        variables.jStream.generate( 

            createDynamicProxy(
                new proxies.Supplier( arguments.supplier ),
                "java.util.function.Supplier"
            )

        );
        return this;
    }

    /**
     * Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length.
     * Please see warnings for parallel streams: https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#limit-long-
     */
    Stream function limit( required numeric maxSize ){
        variables.jStream.limit( javaCast( "long", arguments.maxSize ) );
        return this;
    }

    /**
     * Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, 
     * producing a Stream consisting of seed, f(seed), f(f(seed)), etc.
     * The first element (position 0) in the Stream will be the provided seed. For n > 0, the element at position n, 
     * will be the result of applying the function f to the element at position n - 1.
     * 
     * Each f receives the previous seed
     * 
     * @seed the initial element
     * @f a function to be applied to to the previous element to produce a new element
     * 
     */
    Stream function iterate( required seed, required f ){
        variables.jStream.iterate( 
            arguments.seed,
            createDynamicProxy(
                new proxies.UnaryOperator( arguments.f ),
                "java.util.function.UnaryOperator"
            )

        );
        return this;
    }

    /**
     * Returns a sequential ordered IntStream from start (inclusive) to end (exclusive) by an incremental step of 1.
     * See https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html
     */
    Stream function range( required numeric start, required numeric end ){
        variables.jStream = variables.longStream.range(
            javaCast( "long", arguments.start ),
            javaCast( "long", arguments.end )
        );
        return this;
    }

    /**
     * Returns a sequential ordered IntStream from start (inclusive) to end (inclusive) by an incremental step of 1.
     * See https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html
     */
    Stream function rangeClosed( required numeric start, required numeric end ){
        variables.jStream = variables.longStream.range(
            javaCast( "long", arguments.start ),
            javaCast( "long", arguments.end )
        );
        return this;
    }

    /**************************************** OPERATIONS ****************************************/



    /**************************************** TERMINATORS ****************************************/


}